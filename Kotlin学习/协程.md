

## 协程

```
    implementation "org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.4"
    implementation "org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.4"
```

- kotlin协程在jvm本质上就是切线程，靠线程池来实现

- 挂起就是执行完后再切回来，本质是基于状态机得switch(lable)流转

- suspend本身没有实现挂起，只是一个提示

#### 1.启动方式 launch,async

- 通常

```kotlin
init {
	//1.如果没有指定线程，就在主线程运行
    // GlobalScope 作为 app level 协程w
    GlobalScope.launch(Dispatchers.Main) {
        getBitmapFromNet()  // 1.通过网络加载图片
        showBitmap1()       // 2.在界面上展示原图
     
 }
//withContext(Dispatchers.IO)和suspend关键词，就代表这个函数需要在IO线程运行。线程会自动切换
suspend fun getBitmapFromNet(String url): Bitmap = withContext(Dispatchers.IO) {
        Bitmap bitmap = ...
        return@withContext bitmap
    }
    
 fun showBitmap1(Bitmap bitmap){
    }
```

- 合并网络请求

```kotlin
GlobalScope.launch(Dispatchers.Main) { 
            try {
    		   launch { fetchDoc(1) } //无法获得结果
                val bluerheaven = async { api.listReposKt("bluerheaven") }
                val google = async { api.listReposKt("google") }
                textView.text = "${bluerheaven.await()[0].name} + ${google.await()[0].name}"
            }catch (e: Exception) {
                textView.text = e.message
  }
```

### 2.cancel

非挂起函数，无法取消，比如Thread.sleep，需要在sleep结束后调用ensureActive检测

若不取消，协程可能会泄漏

安卓提供了一些scope，会自己处理取消

```
       lifeCycleScope.launch{
       }
       lifeCycleScope.launchWhen···{
       }
       viewModelScope.launch {
       }
```



### 3.作用域

viewmodelscope-对应viewmodels
lifecycleScope-对应lifecycles
livedataScope-对应livedata{}

### 4.结构化并发

普通Job:协程的异常会抛出并影响 父兄 协程 的执行,CancleException例外

SupevisorJob: 可以阻止这种行为

```kotlin
/**
* 默认的job还是结构化并发，可以使用SupervisorJob	
 */
@Suppress("FunctionName")
public fun CoroutineScope(context: CoroutineContext): CoroutineScope =
    ContextScope(if (context[Job] != null) context else context + Job())
```

​	

#### 5.flow

上游生产是否依赖于下游消费

依赖：冷流

不依赖：热流






## 动态加载应用

[TOC]

### 双亲委派模型 安全 + 避免重复加载

BootstrapClassLoader  （java.lang.Object）启动类加载器 

ExtensionClassLoader  

ApplicationClassLoader 应用程序类加载器 dalvik.system.PathClassLoader

UserDefinedClassLoader 自定义类加载器

如果用户写一个java.lang.object放入程序，能正常编译但不会加载运行，保证不会出现错乱

同样的字节代码，被不同的类加载器加载之后所得到的类，也是不同的


```java
 protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
            // First, check if the class has already been loaded
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                try {
                    if (parent != null) {//父类加载器优先加载
                        c = parent.loadClass(name, false);
                    } else {
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
                }

                if (c == null) {
                    // If still not found, then invoke findClass in order
                    // to find the class.
                    c = findClass(name);
                }
            }
            return c;
    }
```



### 热修复 

java ->class ->dex

- 加载Dex的类BaseDexClassLoader - DexPathList-dexElements（存储Dex）
- DexClassLoader + PathClassLoader 
- 只要把补丁dex文件放到dexElements数组的头部，就可以先一步被加载
- 类加载的双亲委派机制，保证已经被加载的类不会被重复加载

#### 插件化

优点：

- 规避 一些安卓市场的限制
- 动态修复
- 体积
- 启动速度
- 65535

缺点：

复杂，兼容性



1.通过DexClassLoader加载插件apk

我们正常安装到手机里面的APK所包含的类都是使用 PathClassLoader 进行加载的，而 PathClassLoader 所持有的 parent 则是 BootClassLoader

DexClassLoader 加载磁盘中apk，形成了一个从子到父的链

2.资源文件参与编译在R中注册
 packageManager拿到资源

重写Context的getResource方法

```
        //创建我们自己的Resource
        String apkPath = Environment.getExternalStorageDirectory().getAbsolutePath() + "/chajian_demo.apk";

        //创建AssetManager
        assetManager = AssetManager.class.newInstance();
        Method addAssetPathMethod = assetManager.getClass().getDeclaredMethod("addAssetPath", String.class);
        addAssetPathMethod.setAccessible(true);

        addAssetPathMethod.invoke(assetManager, apkPath);


        Method ensureStringBlocks = AssetManager.class.getDeclaredMethod("ensureStringBlocks");
        ensureStringBlocks.setAccessible(true);
        ensureStringBlocks.invoke(assetManager);

        Resources supResource = getResources();
        Log.e("Main", "supResource = " + supResource);
        newResource = new Resources(assetManager, supResource.getDisplayMetrics(), supResource.getConfiguration());

        mTheme = newResource.newTheme();
        mTheme.setTo(super.getTheme());
```




3.manifest未注册组件 占坑+ hook

- hook Instrumentation
- Hook IActivityManager.startActivity和和ActivityThread.mH.mCallback
- hook classLoader



### AndFix  

1.class-jar

修复包 *.dex  本质： 替换方法区中的方法表

```
java虚拟机，* .class -->main函数，开辟进程和内存
栈，堆，方法区
方法的执行在栈，压栈
```

2.必须通过c++   check    Include C++ support  check

3.class-->dex

4.Location-->@Replace(clazz="全类名"，method="")

Fix.class-->dex
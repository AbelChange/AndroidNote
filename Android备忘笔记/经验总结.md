[TOC]


## 热修复原理
java ->class ->dex

加载Dex的类：DexClassLoader + PathClassLoader 
其父类：BaseDexClassLoader 的field DexPathList存储Dex
当App加载dex文件时，就会从DexPathList－dexElements数组里顺序寻找
只要把补丁dex文件放到dexElements数组的头部，就可以先一步被加载
由于类加载的双亲委派机制，已经被加载的类不会被重复加载
就实现了热修复


## 加密

 MD5 算法是一种哈希算法,一般无法解密，所以不叫加密
 base64 可以进行直接还原，所以不叫加密，可用来传输图片，节省一次请求

## java8大基本数据类型比较

| 数据类型 |  包装类   | 位数 | 默认值 | 取值范围                 |
| :------: | :-------: | :--: | :----: | ------------------------ |
|   byte   |   Byte    |  8   |   0    | -2^7 - 2^7-1/ (-128-127) |
|  short   |   Short   |  16  |   0    | -2^15 - 2^15-1           |
|   int    |  Integer  |  32  |   0    | -2^31 - 2^31-1           |
|   long   |   Long    |  64  |   0    |                          |
|  float   |   Float   |  32  |   0    |                          |
|  double  |  Double   |  64  |   0    |                          |
|   char   | Character |  16  |  空格  |                          |
| boolean  |  Boolean  |  8   | false  |                          |

- 位数：位数中，首位代替正负，其余的代表大小
- 包装类中，前六个中继承 Number，均实现了Comparable，可以直接Collection.sort()
- Interger面像对象，可以为null,而int只能为0，提供了一些静态API
- 与集合类合作使用时只能使用包装类型

## View的事件分发机制

```java

1.- 事件处理包括三种情况，分别为：
  传递—-dispatchTouchEvent()函数,
  拦截——onInterceptTouchEvent()函数
  消费—-onTouchEvent()函数
 - 事件类型分为ACTION_DOWN, ACTION_MOVE,ACTION_UP ,每个事件都是以ACTION_DOWN开始ACTION_UP/ACTION_CANCEL结束

  public boolean dispatchTouchEvent(MotionEvent ev){
    boolean consume = false;
	if(!disallowIntercept && onInterceptTouchEvent()){
        consume = onTouchEvent();
    }else{
        consume = anyChild.dispatchTouchEvent()
    }	    
     return consume; 
  }


2.事件传递流程
	//Activity自己不阻断就分发给子view
  Activity.dispatchTouchEvent(MotionEvent ev)-->window->DecorView的dispatchTouchEvent()
  View.dispatchTouchEvent()

3.拦截事件在处理滑动冲突的时候重写相关方法，在MOVE序列 中判断是否需要拦截

```

#### case1:Parent不拦截

当child作为Button，默认消费

```
Parent-dispatchTouchEvent,action：0
Parent-onInterceptTouchEvent,action：0
Child-dispatchTouchEvent,action：0
Child-onTouchEvent,action：0 
//如找到一个子view消费了事件，则继续分发事件到事件序列终止
Parent-dispatchTouchEvent,action：2
Parent-onInterceptTouchEvent,action：2	
//抬起
Parent-dispatchTouchEvent,action：2
Parent-onInterceptTouchEvent,action：1
Child-dispatchTouchEvent,action：1
Child-onTouchEvent,action：1
```

当child作为TextView，默认不消费

```
Parent-dispatchTouchEvent,action：0
Parent-onInterceptTouchEvent,action：0
Child-dispatchTouchEvent,action：0
Child-onTouchEvent,action：0
//回传事件到上层view
Parent-onTouchEvent,action：0
```

#### case2:Parent拦截

parent自身未消费

```
Super-dispatchTouchEvent,action：0
Super-onInterceptTouchEvent,action：0
Parent-dispatchTouchEvent,action：0
Parent-onInterceptTouchEvent,action：0
Parent-onTouchEvent,action：0
//回传事件到上层view
Super-onTouchEvent,action：0
```

parent自身消费

```
类似于parent与button
```

​	

## Activity

### Activity四种启动模式

- Standard  可以重复的启动返回栈里已存在的Activity

- SingleTop  只复用栈顶的

  商品详情界面 -onNewIntent处理数据，接收通知启动的内容显示页面，可以避免重复点击界面多开问题

- SingleTask    只属于某一个 Task
  TaskA启动TaskB的界面，如果TaskB中已经存在该界面，会clear该界面上的界面
  而回退把TaskB中所有Activity关掉后才会回到TaskA(伴随task 切换动画)
  场景：适合作为应用入口，在其他界面重新打开主界面，会将之上所有界面clear

- SingleInstance 
  除了singleTask唯一性，还强调独占性，单独占用一个Task
  场景：跨App交互，可以和App分离的界面，如闹铃设置



### Activity生命周期
启动A
A : createA->StartA->ResumeA 
A打开B
PauseA->CreateB->StartB->ResumeB->StopB

需要注意的是：activity因为内存不足被系统杀死情况下，进程都没了，stop 和 destory就不会被回调，因此关键性数据保存放在onPaunse里比较合适，
但是onPause执行耗时操作会影响下个界面的启动速度

### 传递数据

- 如activity间传输数据，而Serializable可将数据持久化方便保存，所以**在需要保存或网络传输数据时选择Serializable**，因为android不同版本Parcelable可能不同，所以不推荐使用Parcelable进行数据持久化


- Serializable序列化不保存静态变量，堆使用Transient关键字对不序列化，也可以覆盖writeObject、readObject方法以实现序列化过程自定义

1.在使用内存的时候，Parcelable 类比Serializable性能高，所以推荐使用Parcelable类。
2.Serializable在序列化的时候会产生大量的临时变量，从而引起频繁的GC。
3.Parcelable不能使用在要将数据存储在磁盘上的情况，因为Parcelable不能很好的保证数据的持续性在外界有变化的情况下。尽管Serializable效率低点， 也不提倡用，但在这种情况下，还是建议你用Serializable

### 如何设置Activity切换动画

overridePendingTransition(android.R.anim.fade_in,android.R.anim.fade_out);

## 自定义View

onMeasure,决定子view的大小
MeasureSpec  
- Exactly 子View大小由specSize决定
- AT_MOST  子view大小最多是specSize
- UNSPECIFIED 无限制（很少使用）

onLayout 确定子view的位置

onDraw  确定子view内容 Canvas.draw()

onTouchEvent 处理触摸事件


requestLayout,递归向顶级view请求重新Measure与Layout，所以会引起其他view的onMeasure,onLayout

invalidate,只是重新调用onDraw



## 泛型作用：  

```
1.List<String> 保证类型安全
2.扩展性 求和方法（int,float.double）

```

## 并发修改异常ConcurrentModificationException

#### 1.单线程环境下抛出异常

-    Iterator在遍历时，如果**list.add/remove**  会抛出该异常

- foreach的底层是Iterator

- 建议Iterator.add/remove(),普通for循环 会 漏删（当两个元素相邻时）

  ```java
  ArrayList<String> list = new ArrayList<String>(Arrays.asList("a","b","c","d"));
  Iterator<String> iterator = list.iterator();
  while(iter.hasNext()){
          String s = iter.next();
          if(s.equals("a")){
              iterator.remove();
  		//如果需要add set可以使用listiterator
      }
  }
  ```

  本质： hasnext方法会检测modCount(list的size修改次数)与iterator的修改次数是否相等


#### ArrayList vs LinkedList

| 复杂度     | 随机访问 | 增删             |
| ---------- | -------- | ---------------- |
| ArrayList  | O(1)     | O(1)尾)~O(n)(头) |
| LinkedList | O(n)     | O(1)             |

LinkedList不要用for循环遍历，建议使用foeEach或者迭代器

#### HashMap 的实现原理 

hashmap ：数组+链表

```java
//初始 table数组capacity 为 1 << 4 = 16 = table.lenth
//负载因子loadFactor = 0.75  
//threshold = capacity * loadFactor = 12
Node<K,V>[] table //数据结构 :数组 + 链表/树
//put过程    
	//table.lenth	
    //当向HashMap中put(key,value)时，会首先通过(n - 1) & hash（key）算法计算出存放到table数组索引 [0,15]
    //遍历链表插入尾部，当链表深度为 TREEIFY_THRESHOLD = 8 时，转换为红黑树
    //最后判断 map.size > threshold 时会 resize
   //resize过程  第一次put时会初始化table.length = 16
    //2倍扩容（Node位置要么在原位置，要么偏移 原位置 + oldCapacity）    
	//当数组初始长度为16的时候，每次扩容都为之前的2倍，那么就保证了每次扩容之后新数组的最大索引值对应的二进制数为全1。根据2.1小节中，图片标识的(n-1)&hash，那么就能保证添加到HashMap中key的hash值与最大索引相与时，能够最大化的分散到HashMap所有的 bucket 中，进而最大化避免出现hash碰撞使结构复杂
```



![hashmap的put过程](img/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/hashmap%E7%9A%84put%E8%BF%87%E7%A8%8B.png)

#### String传参

- String的内容不能被动态地修改，因为底层是final字符数组实现的，数组的大小是在初始化时决定的；
- StringBuilder可以修改，底层是可变数组
- string与基本类型按值传递，不会影响变量本身

#### socket编程

心跳包实现原理

1.客户端发心跳包时启动一个定时任务
2.收到服务器心跳包返回时，移除上一个定时任务，并重新定时
3.如果定时任务被执行，意味着超时

## 新版本特性

### 11.0

- 分区存储

  对于私有数据，可以存放到App私有目录
  需要共享的可以放到MediaStore对应资源下，通过MediaStore.Uri访问

- 授权其他App访问专属目录需要通过FileProvider

- 权限变更：

  WRITE_EXTERNAL_STORAGE 不再使用，

  READ_EXTERNAL_STORAGE只能读取多媒体文件

  单次权限

  闲置应用权限自动重置

  应用包可见性

**8.0**

- 应用无法使用其清单注册大部分隐式广播
- 对后台限制加大
- WebView 只能使用 HTTPS 

**7.0**

- FileUri->ContentUri


## recyclerview优化

1.飞速滑动时停止加载
2.设置监听方式：在onCreateViewHolder时设置监听，通过接口回调出去，通过holder.getLauoutPostion获取点击位置

```
public class RequestBuilder{
  
  private <Y extends Target<TranscodeType>> Y into(
      @NonNull Y target,
      @Nullable RequestListener<TranscodeType> targetListener,
      @NonNull RequestOptions options) {

    Util.assertMainThread();
	.
	//使用viewtarget构造请求
    Request request = buildRequest(target, targetListener, options);
	//得到该view上一个请求
    Request previous = target.getRequest();
		//如果相等//这里构建request需要requestOPtions
    if (request.isEquivalentTo(previous)
        && !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) {
		//取消当前请求,使用previous
      request.recycle();
      if (!Preconditions.checkNotNull(previous).isRunning()) {
        previous.begin();
      }
      return target;
    }
	
	//如果不等
	//1.取消上一个请求
    requestManager.clear(target);
    //2.使用view.setTag方法将request绑定当前view
    target.setRequest(request);
    requestManager.track(target, request);
    return target;
  }
  
}
```



2.图片加载错乱使用settag方式异常

Glide默认使用view.setTag(tag)标记请求，你就不能重复调用了。 解决办法：如果你需要为ImageView设置Tag，必须使用setTag(int key, final Object tag)及getTag(int key)方法，其中key设置为resourceID,value使用url即可作者：Android开发__落岑链接：https://www.jianshu.com/p/ffb6e57e9c9e

3.Glide三级缓存，ActiveResources（使用中缓存，保证不会被LRu回收）,Memorycache（HashMap + Lru）,DiskCache

数据持久化应该放在onPause中进行



对于只用于应用内的广播，优先使用 LocalBroadcastManager 来进行注册和发送，
LocalBroadcastManager 安全性更好，同时拥有更高的运行效率

当前 Activity 的 onPause 方法执行结束后才会创建（onCreate）或恢复（onRestart）别
的 Activity，所以在 onPause 方法中不适合做耗时较长的工作，这会影响到页面之间的跳转效

在 Activity#onPause()或 Activity#onStop()回调中，关闭当前 activity 正在执行的的动
画

图片编码格式 RGB_888 ->RGB_565

在有强依赖 onAnimationEnd 回调的交互时，如动画播放完毕才能操作页面 ，
onAnimationEnd可能会因各种异常没被回调 （ 参 考 https://stackoverflow.com/questions/547
4923/onanimationend-is-not-getting-calld-onanimationstart-works-fine ）， 建议加上超时保
护或通过postDelay替代onAnimationEnd。



## ui绘制流程

ActivityThread

->setContentView   contentview关联decorview

-> handleResume   关联当前window与decorView
    activity.wm.addView(decor) 

->ViewRootImpl - scheduleTraversals()

```java
class WindowManagerGlobal{
   void addView(View view, ViewGroup.LayoutParams params,
            Display display, Window parentWindow){
       ViewRootImpl root = new ViewRootImpl(context,display) ;
       root.setView(decorview, params, panelParentView);
    }
}
```

```java
class ViewRootImpl{
      void scheduleTraversals(){
          //发送同步屏障
         mHandler.getLooper().getQueue().postSyncBarrier();
   		//Posts a callback to run on the next frame（当vsync信号来之后执行）
      mChoreographer.postCallback(
                          Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);
      //mTraversalRunnable
	final class TraversalRunnable implements Runnable {
        @Override
        public void run() {
			
            doTraversal(); 
        }
    }
	//移除屏障 加绘制
    doTraversal(){
     移除同步屏障 + 绘制
    }     
}
```



### Measure

MeasureSpec：32位int   SpecMode (2) + SpecSize(30)

DecorView MeasureSpec由Window大小与自身LayoutParams决定

ViewGroup onMeasure --

View 的 MesureSpec 由父容器MeasureSpec 与 自身的LayoutParams共同决定	

VIew   onLayout  - setFrame


ViewGroup onLayout - layoutChild

## Service
8.0开始限制后台服务，9.0需要授予权限

start: create + startCommand
多次启动该服务，可以根据startId区分任务
bind: create  + bind 需要交互的服务开启

IntentService = HandlerThread 控制了hanldleIntent位于子线程工作,
消息处理完之后调用stopService(startId)，不用手动销毁

多次start 会串行执行任务，handler机制



## Router

```java

class ServiceLoader{

 	public static <I, T extends I> T getService(Class<I> clazz, String key) {
        return ServiceLoader.load(clazz).get(key);
    }

    /**
     * IntercfaceClass获取ServiceLoader
     */
    private static final Map<Class, ServiceLoader> SERVICES = new HashMap<>();

    /**
     * key --> 反射具体实现类
     */
    private HashMap<String, ServiceImpl> mMap = new HashMap<>();

}






```




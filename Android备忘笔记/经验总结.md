[TOC]

### SystemClock时间/时长

| 方法                             | 返回值                                    | 适用场景                                                     |
| -------------------------------- | ----------------------------------------- | ------------------------------------------------------------ |
| **`currentTimeMillis()`**        | 1970年1月1日以来的实际时间（Unix 时间戳） | 获取实际当前时间，时间戳对比，日期计算                       |
| **`elapsedRealtime()`**          | 设备开机时长（总）                        | 测量设备从开机到现在的时间，比较少使用                       |
| **`SystemClock.uptimeMillis()`** | 设备开机时长（活跃，不包括睡眠）          | handler 计算when  = SystemClock.uptimeMillis() + delayMillis |



### 图片大小计算方式

- 目录dpi :xhdpi 为 320  

- 设备dpi. pixels  per inch 勾股定理 + 屏幕尺寸  

Bitmap decode之后像素点个数会适应变化

- Bitmap.Config.ALPHA_8:   一个像素 1Byte

- Bitmap.Config.ARGB_8888：一个像素 4Byte

图片大小 = 图片像素点数  * （设备dpi/目录dpi)^2  * 格式相关

### 安卓事件传递流程

1.- 事件处理包括三种情况，分别为：
  传递—-dispatchTouchEvent()函数,
  拦截——onInterceptTouchEvent()函数
  消费—-onTouchEvent()函数

 - 事件类型分为ACTION_DOWN, ACTION_MOVE,ACTION_UP ,每个事件都是以ACTION_DOWN开始ACTION_UP/ACTION_CANCEL结束

```java
//ViewGroup
  public boolean dispatchTouchEvent(MotionEvent ev){
    boolean consume = false;
      if(!disallowIntercept && onInterceptTouchEvent()){
          consume = onTouchEvent();
      }else{
          consume = anyChild.dispatchTouchEvent()
      }	    
			//如果没找到Child
			if(child==null){
        return super.dispatchTouchEvent(ev)
      }
       return consume; 
  }


//View 返回值代表是否分发成功
 click判定依赖于onTouchEvent的up事件，onTouchListner > onTouchEvent
 public boolean dispatchTouchEvent(MotionEvent event) {
	...
		//如果设置了onTouchListner 返回true，也是分发成功
    ListenerInfo li = mListenerInfo;
        if (li != null && li.mOnTouchListener != null
                && (mViewFlags & ENABLED_MASK) == ENABLED
                && li.mOnTouchListener.onTouch(this, event)) {
            result = true;
        }
				//如果消费了代表分发成功	
        if (!result && onTouchEvent(event)) {
            result = true;
        }
			... 
 }

```

2.事件传递流程
	//Activity自己不阻断就分发给子view
  window->DecorView的dispatchTouchEvent()
  View.dispatchTouchEvent()

- 拦截事件在处理滑动冲突的时候重写相关方法，在MOVE序列 中判断是否需要拦截
- 如果down事件分发失败，则事件上传给父级onTouch，后续Move、Up不会再传递了
- Down被view消费了，则后续move up不被拦截情况下都会去找该view
- 如果后续得move被拦截了，补发一个cancel给view,流向目标修改

## Activity

### Activity四种启动模式

- Standard  可以重复的启动返回栈里已存在的Activity

- SingleTop  只复用栈顶的

  商品详情界面 -onNewIntent处理数据，接收通知启动的内容显示页面，可以避免重复点击界面多开问题
  通知打开消息页面

- SingleTask   
  
  寻找目标Activity所在Task
  
  如果未找到，则创建Task，创建activity放入该Task，之后并入前台Task
  
  如果找到了则先暴漏目标Acvitiy，将该Task并入当前前台Task（如果两个Task的taskAffinity不同，则进入后台后，两个栈会分开）
  
  场景：适合作为应用入口，在其他界面重新打开主界面，会将之上所有界面clear
  
  [singleTask图示](https://s2.51cto.com/images/blog/202205/27182650_6290a76ab57ad17033.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=/format,webp/resize,m_fixed,w_1184)
  
- SingleInstance  
  除了singleTask唯一性，还强调独占性，单独占用一个Task
  场景：跨App交互，可以和App分离的界面，如闹铃设置，拨号界面
  必须具有清单文件中的CATEGORY_LAUNCHER和ACTION_MAIN过滤器

- taskAffinity

  当初次启动一个App时，系统会创建一个Task，这个Task会得到一个`taskAffinity`，这个`taskAffinity`的值就是第一个Activity的`taskAffinity`，默认为应用包名

- allowTaskReparenting

  在切换应用时，允许activity在不同taskAffinity的任务栈中转移，要还的

### Activity生命周期

#### A页面跳转B页面的生命周期： pause到另外一个resume再stop
A : createA->StartA->ResumeA 
A打开B
PauseA->CreateB->StartB->ResumeB->StopA

需要注意的是：activity因为内存不足被系统杀死情况下，进程都没了，stop 和 destory就不会被回调，因此关键性数据保存放在onPause里比较合适，
但是onPause执行耗时操作会影响下个界面的启动速度

### sp的问题
commit同步执行导致anr
apply是异步执行的，handleStopActivity会通过wait保证异步任务已经执行完毕，此处可能导致anr

### 传递数据

- 如activity间传输数据，而Serializable可将数据持久化方便保存，所以**在需要保存或网络传输数据时选择Serializable**，因为android不同版本Parcelable可能不同，所以不推荐使用Parcelable进行数据持久化


- Serializable序列化不保存静态变量，堆使用Transient关键字对不序列化，也可以覆盖writeObject、readObject方法以实现序列化过程自定义

Parcelable 属于安卓，

1.在使用内存的时候，Parcelable 类比Serializable性能高，所以推荐使用Parcelable类。
2.Serializable在序列化的时候会产生大量的临时变量，从而引起频繁的GC。
3.磁盘存储推荐Serializable

```java
@Override

protected void onResume() {

super.onResume();

final long start = System.currentTimeMillis();

getWindow().getDecorView().post(new Runnable() {

    @Override

    public void run() {

    new Hanlder().post(new Runnable() {

    @Override

    public void run() {

      Log.d(TAG, "onPause cost:" + (System.currentTimeMillis() - start));

    }
```

## Service
8.0开始限制后台服务，9.0需要授予权限

start: create + startCommand

bind: create  + bind 需要交互的服务开启

HandlerThread 自带Looper的Thread

IntentService = HandlerThread 控制了hanldleIntent位于子线程工作,
多次启动该服务，可以根据startId区分任务
消息处理完之后调用stopService(startId)，不用手动销毁

多次start 会串行执行任务，handler机制



## Router


**ARouter 的路由表是在编译期“生成了装填 map 的代码”，但只有在运行时调用 init() 时，这些类才会被反射调用，真正把路径注册进 Map。**

使用时候根据路由表信息找到对应的class执行具体的行为

```java

class ServiceLoader{

 	public static <I, T extends I> T getService(Class<I> clazz, String key) {
        return ServiceLoader.load(clazz).get(key);
    }

    /**
     * IntercfaceClass获取ServiceLoader
     */
    private static final Map<Class, ServiceLoader> SERVICES = new HashMap<>();

    /**
     * key --> 反射具体实现类
     */
    private HashMap<String, ServiceImpl> mMap = new HashMap<>();

}



```

## 自定义View

onMeasure阶段，子 View 会根据父 View 传递的 MeasureSpec 来计算自己的 measuredWidth 和 measuredHeight

- UNSPECIFIED
  The parent has not imposed any constraint on the child. It can be whatever size it wants.
  //父布局不约束子布局大小，想多大就多大

- EXACTLY
  The parent has determined an exact size for the child. The child is going to be given those bounds regardless of how big it wants to be.
  //父布局约束子view大小为一个确定值,

- AT_MOST
  The child can be as large as it wants up to the specified size.

  //限制最大值

  

**requestLayout方法只会导致当前view的measure和layout，而draw不一定被执行，只有当view的位置发生改变才会执行draw方法，因此如果要使当前view重绘需要调用invalidate。**



getMeasuredWidth() → onMeasure() 得到的自身测量结果

getWidth()    → 父 View layout() 之后 分配给自己的实际显示宽度, right-left


```java
//自身的测量 需要父view的measureSpec + 自己要求的size决定
override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {
    val child = getChildAt(0)
    child.measure(widthMeasureSpec, heightMeasureSpec)
    val w = child.getMeasuredWidth()
    val h = child.getMeasuredHeight()
    setMeasuredDimension(w, h)
}
```

可以**先算尺寸，再决定是否 requestLayout**



## 新版本特性

### 13.0

使用通知时会弹出通知权限
splash

### 12.0

- android:exported
- 新增蓝牙权限,不再需要申请设备位置信息相关权限
- WorkManager 升级

### 11.0

- 分区存储

  对于私有数据，可以存放到App私有目录
  需要共享的可以放到MediaStore对应资源下，通过MediaStore.Uri访问

- 授权其他App访问专属目录需要通过FileProvider

- 权限变更：

  WRITE_EXTERNAL_STORAGE 不再使用，

  READ_EXTERNAL_STORAGE只能读取多媒体文件

  单次权限

  闲置应用权限自动重置

  应用包可见性

**8.0**

- 应用无法使用其清单注册大部分隐式广播
- 对后台限制加大
- WebView 只能使用 HTTPS 

**7.0**

- FileUri->ContentUri


## recyclerview优化

1.飞速滑动时停止加载
2.设置监听方式：在onCreateViewHolder时设置监听，通过接口回调出去，通过holder.getLauoutPostion获取点击位置

```
public class RequestBuilder{
  
  private <Y extends Target<TranscodeType>> Y into(
      @NonNull Y target,
      @Nullable RequestListener<TranscodeType> targetListener,
      @NonNull RequestOptions options) {

    Util.assertMainThread();
	.
	//使用viewtarget构造请求
    Request request = buildRequest(target, targetListener, options);
	//得到该view上一个请求
    Request previous = target.getRequest();
		//如果相等//这里构建request需要requestOPtions
    if (request.isEquivalentTo(previous)
        && !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) {
		//取消当前请求,使用previous
      request.recycle();
      if (!Preconditions.checkNotNull(previous).isRunning()) {
        previous.begin();
      }
      return target;
    }
	
	//如果不等
	//1.取消上一个请求
    requestManager.clear(target);
    //2.使用view.setTag方法将request绑定当前view
    target.setRequest(request);
    requestManager.track(target, request);
    return target;
  }
  
}
```



2.图片加载错乱使用settag方式异常

Glide默认使用view.setTag(tag)标记请求，你就不能重复调用了。 解决办法：如果你需要为ImageView设置Tag，必须使用setTag(int key, final Object tag)及getTag(int key)方法，其中key设置为resourceID,value使用url即可作者：Android开发__落岑链接：https://www.jianshu.com/p/ffb6e57e9c9e

数据持久化应该放在onPause中进行

对于只用于应用内的广播，优先使用 LocalBroadcastManager 来进行注册和发送，
LocalBroadcastManager 安全性更好，同时拥有更高的运行效率

当前 Activity 的 onPause 方法执行结束后才会创建（onCreate）或恢复（onRestart）别
的 Activity，所以在 onPause 方法中不适合做耗时较长的工作，这会影响到页面之间的跳转效

在 Activity#onPause()或 Activity#onStop()回调中，关闭当前 activity 正在执行的的动
画

图片编码格式 RGB_888 ->RGB_565

在有强依赖 onAnimationEnd 回调的交互时，如动画播放完毕才能操作页面 ，
onAnimationEnd可能会因各种异常没被回调 （ 参 考 https://stackoverflow.com/questions/547
4923/onanimationend-is-not-getting-calld-onanimationstart-works-fine ）， 建议加上超时保
护或通过postDelay替代onAnimationEnd。



## GCROOT （不回收，生命周期伴随jvm）

1.native 栈          --方法中的变量或者方法形参

2.jvm虚拟机栈    -- 方法中的变量或者方法形参

3.常量对象与静态对象（方法区）

4.活动的线程






# 性能优化

[TOC]

## 前言:java垃圾回收机制-GC(Garbage-Collection)

____

`引用计数法`：通过判断对象的引用数量来决定对象是否可以被回收，任何引用计数为0的对象实例可以被当做垃圾收集
优：执行效率高，程序执行受影响小
缺：无法检测出循环引用的情况，导致内存泄漏。eg：父对子有一个引用，子对父也有一个引用，所以两个对象引用用不为0

`可达性分析`：判断对象的引用链是否可达来决定对象是否可以被回收，通过GC Root到各对象是否可达来判断
可作为GC Root的对象：虚拟机栈中引用的对象(栈帧中的本地变量表)，方法区中的常量引用的对象，方法区中的类静态属性引用的对        象，本地方法栈中JNI(Native)的引用对象，活跃线程的引用对象

四种引用类型区别：

强：宁愿oom也不回收
软：在将要抛出oom之前回收
弱：存活到下一次GC前（ 静态内部类+弱引用 handler 可以避免内存泄漏）
虚：没引用关系，任意时间都会被回收

___



## 1.卡顿分析：

### 1.1描述

本质是android刷新率是60fps，16ms无法完成渲染
可能原因：

- 布局过于复杂，overDraw ：viewStub, merge,include
- UI线程耗时
- GC频繁

### 1.2卡顿监测 blockcanary

android界面绘制是事件驱动的，定位到mainlooper.loop()方法，如果dispatchMessage方法执行事件超过16ms，则可认为发生了卡顿



```java
Choreographer.java
    /**
     * FrameDisplayEventReceiver继承自DisplayEventReceiver接收底层的VSync信号开始处理UI过程。
     * VSync信号由SurfaceFlinger实现并定时发送。FrameDisplayEventReceiver收到信号后，
     * 调用onVsync方法组织消息发送到主线程处理。这个消息主要内容就是run方法里面的doFrame了，
     * 这里mTimestampNanos是信号到来的时间参数。
     */
    private final class FrameDisplayEventReceiver extends DisplayEventReceiver
            implements Runnable {
        private boolean mHavePendingVsync;
        private long mTimestampNanos;
        private int mFrame;

        public FrameDisplayEventReceiver(Looper looper, int vsyncSource) {
            super(looper, vsyncSource);
        }

        @Override
        public void onVsync(long timestampNanos, int builtInDisplayId, int frame) {
            mTimestampNanos = timestampNanos;
            mFrame = frame;
            // 发送Runnable(callback参数即当前对象FrameDisplayEventReceiver)到FrameHandler，请求执行doFrame
            Message msg = Message.obtain(mHandler, this);
            //vsync信息消息是异步消息
            msg.setAsynchronous(true);
            // 此处mHandler为FrameHandler，该Handler对应的Looper是主线程的Looper
			//分发消息是串行的 如果有个消息分发超过了 16ms 则绘制消息无法及时处理
            mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);
        }

        @Override
        public void run() {
            mHavePendingVsync = false;
            doFrame(mTimestampNanos, mFrame);
        }
    }
```





在loop()函数中，Android完成了Looper消息队列的分发，在分发消息开始，会打印一串log日志：

```java
            logging.println(">>>>> Dispatching to " + msg.target + " " +
                    msg.callback + ": " + msg.what);
```
同时在消息处理结束后也会打印一串消息日志：

```java
logging.println("<<<<< Finished to " + msg.target + " " + msg.callback);
```

分发消息开始到消息结束，理想的情况下应该在16ms以内

```java
 private void check() {
        Looper.getMainLooper().setMessageLogging(new Printer() {
            private final String START = ">>>>> Dispatching to";
            private final String END = "<<<<< Finished to";
 
            @Override
            public void println(String s) {
                if (s.startsWith(START)) {
                    mCheckTask.start();
                } else if (s.startsWith(END)) {
                    mCheckTask.end();
                }
            }
        });
    }
 
    private class CheckTask {
        private HandlerThread mHandlerThread = new HandlerThread("卡顿检测");
        private Handler mHandler;
 		
        private final int THREAD_HOLD = 1000;
 
        public CheckTask() {
            mHandlerThread.start();
            mHandler = new Handler(mHandlerThread.getLooper());
        }
 
        private Runnable mRunnable = new Runnable() {
            @Override
            public void run() {
                log();
            }
        };
 
        public void start() {
            mHandler.postDelayed(mRunnable, THREAD_HOLD);
        }
 
        public void end() {
            mHandler.removeCallbacks(mRunnable);
        }
    }


    /**
     * 输出当前异常或及错误堆栈信息。
     */
    private void log() {
        StringBuilder sb = new StringBuilder();
        StackTraceElement[] stackTrace = Looper.getMainLooper().getThread().getStackTrace();
        for (StackTraceElement s : stackTrace) {
            sb.append(s + "\n");
        }
 
        Log.w(TAG, sb.toString());
    }

```

 本质是判断post的message是否可以在一定时间内被处理

### 1.3.trace文件获取

- cpu profiler -  .trace位于 .app /captures目录下

- 插桩:/sdcard/custom.trace

  ```java
  //custom其实就是生成的TraceView文件的文件名,例如custom.trace
  Debug.startMethodTracing("custom");
  //方法 1-2223
  Debug.stopMethodTracing();
  ```

如果发现某个方法运行时间明显过长或者调用次数异常过多，则就存在优化的可能

## 2.ANR

[ANR-WatchDog](https://link.jianshu.com/?t=https://github.com/SalomonBrys/ANR-WatchDog)

- bugly监测anr的机制：监测对anr日志的写入，AMS- appnotresponding -  fileobserver对日志观察写入
- ANR的日志在data/anr/traces.txt目录下
- bugly监测Exception：UncaughtExceptionHandler

## 3.内存泄漏

工具：strictmode+MemoryProfiler+ LeakCanary

MemeoryProfiler:查看泄漏期间的对象概念

### 3.1StrictMode（开发中）

```java
  if (DEVELOPER_MODE) {
      		//监测耗时操作
            StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder()
                    .detectDiskReads()
                    .detectDiskWrites()
                    .detectNetwork()   // or .detectAll() for all detectable problems
                    .penaltyLog()
                    .build());
      		//监测内存泄漏
            StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder()
                    .detectLeakedSqlLiteObjects()
                    .detectLeakedClosableObjects()
                    .penaltyLog()
                    .penaltyDeath()
                    .build());
   }

```


### 3.2MemoryProfiler + MAT（Eclipse自带，也有独立版本）

- 检查allocationCount是否超过预期
   Shallow Size：此实例的大小
   Retained Size：实际大小（递归）
- 也可导出standard HProf 再使用MAT分析，qql语句搜索，leakSuspect
  	GCRoot可达性分析，找出泄漏原因
- 对比GC前后内存快照

### 3.3LeakCanary （开发中）

- 在合适时机触发检测，对于activity/fragment/service就是onDestroy之后

- ObjectWatcher.expectWeaklyReachable
  弱引用队列如果一直取不到某个ref，则说明可能泄漏watcherObject

  ```kotlin
   override fun expectWeaklyReachable(
      watchedObject: Any,
      description: String
    ) {
  	//将已经回收的对象从watchedObjects移除
  	removeWeaklyReachableObjects()
      //为观察对象创建弱引用
    val reference =
        KeyedWeakReference(watchedObject, key, description, watchUptimeMillis, queue)
  	//将引用关系保存到map：watchedObjects中	
  	    watchedObjects[key] = reference
    }
  
  
  private fun removeWeaklyReachableObjects() {
     //queue放到是 将要回收的ref ，如果一直没取到，说明泄漏了
      var ref: KeyedWeakReference?
      do {
        ref = queue.poll() as KeyedWeakReference?
        if (ref != null) {
          watchedObjects.remove(ref.key)
        }
      } while (ref != null)
    }  
  ```

  

- 延迟任务检测是否回收，如果队列里面还有该对象，说明泄漏未回收则触发GC

- GC后若还未回收就dumpHeap（堆转储分析），GCROOT最短引用路径，确定泄漏引用链		

#### 3.4 Koom

https://www.jianshu.com/p/018febffb06f

## 4.oom

OOM 是可以捕获的，只要 OOM 是由 try 语句中的对象声明所导致的，那么在 catch 语句中，是可以释放掉这些对象，解决 OOM 的问题的

对于图片：
清除图片缓存
使用RGB565等内存占用少的格式

webview：单开进程











